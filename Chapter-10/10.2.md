## 10.2-4

The dynamic-set operation UNION takes two disjoint sets S_1 and S_2 as input, and returns a set S = S_1 \cup S_2 consisting of all 
the element of S_1 and S_2. The sets S_1 and S_2 are usually destroyed by the operation. Show how to support UNION in O(1) time using 
a suitable list data structure.

First adjust the usual linked list class to keep track of the tail.

```plaintext
class ListNode:
    def __init__(self, key):
        self.key = key
        self.prev = None
        self.next = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def list_insert(self, x, y):
        x.next = y.next
        x.prev = y
        if y.next is not None:
            y.next.prev = x
        else:
            self.tail = x
        y.next = x

    def list_prepend(self, x):
        x.next = self.head
        x.prev = None
        if self.head is not None:
            self.head.prev = x
        else:
            self.tail = x
        self.head = x

    def list_delete(self, x):
        if x.prev is not None:
            x.prev.next = x.next
        else:
            self.head = x.next
        if x.next is not None:
            x.next.prev = x.prev
        else:
            self.tail = x.prev
```

Then we can define the union operation simply as follows.

```plaintext

def union(list1, list2):
    if list1.head is None:  # S1 is empty
        list1.head = list2.head
        list1.tail = list2.tail
    elif S2.head is not None:  # S1 is not empty and S2 is not empty
        list1.tail.next = list2.head
        list2.head.prev = list1.tail
        list1.tail = list2.tail
    # list2 is destroyed by dereferencing its head and tail
    list2.head = list2.tail = None
    return list1
```

## 10.2-5

Give a $\Theta (n)$-time nonrecursive procedure that reverses a singly linked list of elements. The procedure should use no more than constant storage beyond that needed for the list itself.

_Answer:_
```plaintext

LIST-REVERSE(L)

    # 1: Initialize pointers
    prev « NIL
    current « L.head

    # 2: Iterate through the list
    while current ≠ NIL do
        next « current.next    # Save the next node before updating current.next
        current.next « prev    # Reverse the pointer
        prev « current         # Move prev forward
        current « next         # Move current forward

    # 3: Update the head
    L.head « prev

```

(i) Updated Search Algorithm

Recall the algorithm for searching a doubly-linked list (P. 260):

```plaintext
Algorithm LIST-SEARCH(L,k)
    current = L.head
    while current ≠ NIL and current.key ≠ k do
        current « current.next
    return current
```

We first prove that c = a $\oplus$ b implies both (1) a = c $\oplus$ b and (2) (1) b = c $\oplus$ a. This will allow us recover the x.next and x.prev operators from the single x.np operator.

Proof.
Suppose c = a \$\oplus\$ b. By the fact that c \$\oplus\$ b = c \$\oplus\$ b and by substitution, we have c \$\oplus\$ b = (a \$\oplus\$ b) \$\oplus\$ b. Then we reason as follows.
1. c \$\oplus\$ b  =  b \$\oplus\$ (a \$\oplus\$ b)  (Commutativity)
2. c \$\oplus\$ b  =  b \$\oplus\$ (b \$\oplus\$ a)  (Commutativity)
3. c \$\oplus\$ b  =  (b \$\oplus\$ b) \$\oplus\$ a  (Associativity)
4. c \$\oplus\$ b  =  0 \$\oplus\$ a                 (Self-Inverse)
5. c \$\oplus\$ b  =  a                              (Identity)

The proof for (2) is identical. It follows that x.next = x.np \$\oplus\$ x.prev and x.prev = x.np \$\oplus\$ x.next.

```plaintext
Algorithm XOR-LIST-SEARCH(L,k)
    # Initialise pointers
    prev « NIL
    current « L.head
    # Traverse list searching for element
    while current.key ≠ k and current ≠ NIL do
        next « current.np XOR prev
        prev « current
        current « next
    return current
```
        
(ii) Updated Insert Algorithm

Recall the algorithm for inserting an element into a doubly-linked list (P. 261):
    
```plaintext
Input: x: element to be inserted; y: pointer to an object in the list
Algorithm LIST-INSERT(x,y)
'''
Inserts x immediately following y in a doubly-linked list.
'''
1.    x.next « y.next
2.    x.prev « y
3.    if y.next ≠ NIL
4.        y.next.prev « x
5.    y.next « x
```

To replicate this for the XOR version of doubly-linked lists, we need to make use of the facts, just proven, that x.next = x.np \$\oplus\$ x.prev and x.prev = x.np \$\oplus\$ x.next. Since we want to update the next part of the np pointer, we need to find the previous element of y. To do that, we re-implement the LIST-SEARCH algorithm, now called FIND-PREV, which finds the previous element 

```plaintext
Algorithm XOR-FIND-PREVIOUS(L,k)
    # Initialise pointers
    prev « NIL
    current « L.head
    # Traverse list searching for element
    while current.key ≠ k and current ≠ NIL do
        next « current.np XOR prev
        prev « current
        current « next
    return prev
```

For this strategy, we need to include this list as an argument to the function. This doesn't seem like a problem.
```plaintext
Input: x: element to be inserted; y: pointer to an object in the list
Algorithm XOR-LIST-INSERT(L,x,y)
'''
Inserts x immediately following y in a doubly-linked list.
'''
1.     prev « XOR-FIND-PREVIOUS(L,y)
2.     y_next « y.np XOR prev
3.    
```
# X
x.next = x.np XOR x.prev
x.prev = x.np XOR x.next
x.np = x.next XOR x.prev

# Y
y.next = y.np XOR y.prev
y.prev = y.np XOR y.next
y.np = y.next XOR y.prev


so we could have:
y_next « y.np XOR y.prev
x_next « y_next

But this doesn't actually update the nps, which is what we want. We actually have to update x.np. But I can still update next and prev bits by updating the relevant bits inside the x.np definition.

Remember: we insert x AFTER y, meaning x becomes next, not the prev, of y.

So could we just do this:

x_next « y.np XOR y.prev
